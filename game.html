<!DOCTYPE html>

<html lang="en">
<head>
<title>WebVR Demo</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0, shrink-to-fit=no">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.2/css/font-awesome.min.css">
<style>
html, body {
	width: 100%;
	height: 100%;
	background-color: #000;
	color: #fff;
	margin: 0px;
	padding: 0;
	overflow: hidden;
}

canvas {
	position: fixed;
	top: 0;
}

#buttons {
	position: fixed;
	bottom: 0;
	right: 0;
	z-index: 1;
	/*to prevent mouse selection of the button*/
	user-select: none;
	-webkit-user-select: none;
}
#buttons i {
	color: #ccc;
	font-size: 150%;
	margin-bottom: 0.4em;
	margin-right: 0.4em;
}
#buttons i:hover {
	color: #fff;
	text-shadow: 0px 0px 5px lightblue, 0px 0px 10px lightblue;
	cursor: pointer;
}
</style>
</head>

<body>

  <div id="buttons">
    <i class="fa fa-volume-off" id='muteButton' title='mute sound'></i>
    <i class="fa fa-volume-up" id='unmuteButton' title='unmute sound'></i>
    <i class="fa fa-arrows-alt" id='fullscreenButton'></i>
    <i class="fa fa-eye" id='vrButton'></i>
    <i class="fa fa-star" id='resetButton' title='reset position'></i>
  </div>

</body>

<script>
WebVRConfig = {
	BUFFER_SCALE: 0.5,
};

document.addEventListener('touchmove', function(e) {
  e.preventDefault();
});
</script>

<!-- three.js library -->
<script src="vendor/three.js/build/three.js"></script>

<!-- VRControls.js applies the WebVR transformations to a three.js camera object. -->
<script src="vendor/three.js/examples/js/controls/VRControls.js"></script>

<!-- VREffect.js handles stereo camera setup and rendering.  -->
<script src="vendor/three.js/examples/js/effects/VREffect.js"></script>

<!-- A polyfill for the WebVR API.  -->
<script src="vendor/webvr-polyfill.js"></script>


<script>

var onRenderFcts = []

// Setup three.js WebGL renderer. Note: Antialiasing is a big performance hit.
// Only enable it if you actually need to.
var renderer = new THREE.WebGLRenderer({antialias: false});
renderer.setPixelRatio(Math.floor(window.devicePixelRatio));

// Append the canvas element created by the renderer to document body element.
document.body.appendChild(renderer.domElement);

// Create a three.js scene.
var scene = new THREE.Scene();

// Create a three.js camera.
var camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 10000);

//////////////////////////////////////////////////////////////////////////////////
//		Comments
//////////////////////////////////////////////////////////////////////////////////
var listener = new THREE.AudioListener();
camera.add( listener );

var audioLoader = new THREE.AudioLoader();
function toggleMute(){
	// debugger
	var isMuted = listener.getMasterVolume() === 0.0 ? true : false 
	if( isMuted ){
		listener.setMasterVolume(1.0)
	}else{
		listener.setMasterVolume(0.0)
	}
	
	updateMuteButton()
}
function updateMuteButton(){
	var isMuted = listener.getMasterVolume() === 0.0 ? true : false 
	if( isMuted ){
		document.querySelector('#unmuteButton').style.display = 'initial'				
		document.querySelector('#muteButton').style.display = 'none'
	}else{
		document.querySelector('#unmuteButton').style.display = 'none'
		document.querySelector('#muteButton').style.display = 'initial'		
	}
}

listener.setMasterVolume(0.0)	// to start muted
// listener.setMasterVolume(1.0)	// to start with sound on
updateMuteButton()

//////////////////////////////////////////////////////////////////////////////////
//		Comments
//////////////////////////////////////////////////////////////////////////////////

// Apply VR headset positional data to camera.
var controls = new THREE.VRControls(camera);

// Apply VR stereo rendering to renderer.
var effect = new THREE.VREffect(renderer);
effect.setSize(window.innerWidth, window.innerHeight);

// Get the VRDisplay and save it for later.
var vrDisplay = null;
navigator.getVRDisplays().then(function(displays) {
	if (displays.length > 0) {
		vrDisplay = displays[0];
	}
	
	if( vrDisplay !== null ){
		if( vrDisplay.capabilities.canPresent !== true ){
			document.querySelector('#vrButton').style.display = 'none'
		}
	}
});


// Request animation frame loop function
var lastRender = 0;
function animate(timestamp) {
	var delta = Math.min(timestamp - lastRender, 500);
	lastRender = timestamp;
	
	// Update VR headset position and apply to camera.
	controls.update();
	
	onRenderFcts.forEach(function(onRenderFct){
		onRenderFct(delta)
	})
	
	// Render the scene.
	effect.render(scene, camera);
	
	// Keep looping.
	requestAnimationFrame(animate);
}

// Kick off animation loop.
requestAnimationFrame(animate);

//////////////////////////////////////////////////////////////////////////////////
//		Comments
//////////////////////////////////////////////////////////////////////////////////

function onResize() {
	console.log('Resizing to %s x %s.', window.innerWidth, window.innerHeight);
	effect.setSize(window.innerWidth, window.innerHeight);
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
}

function onVRDisplayPresentChange() {
	console.log('onVRDisplayPresentChange');
	onResize();
}


// Resize the WebGL canvas when we resize and also when we change modes.
window.addEventListener('resize', onResize);
window.addEventListener('vrdisplaypresentchange', onVRDisplayPresentChange);

// Button click handlers.
document.querySelector('#fullscreenButton').addEventListener('click', function() {
	enterFullscreen(renderer.domElement);
});
document.querySelector('#vrButton').addEventListener('click', function() {
	vrDisplay.requestPresent([{source: renderer.domElement}]);
});
document.querySelector('#resetButton').addEventListener('click', function() {
	vrDisplay.resetPose();
});

document.querySelector('#muteButton').addEventListener('click', function() {
	toggleMute()
});


document.querySelector('#unmuteButton').addEventListener('click', function() {
	toggleMute()
});

function enterFullscreen (element) {
	if (element.requestFullscreen) {
		element.requestFullscreen();
	} else if (element.mozRequestFullScreen) {
		element.mozRequestFullScreen();
	} else if (element.webkitRequestFullscreen) {
		element.webkitRequestFullscreen();
	} else if (element.msRequestFullscreen) {
		element.msRequestFullscreen();
	}
}

//////////////////////////////////////////////////////////////////////////////////
//		add the skybox+ground
//////////////////////////////////////////////////////////////////////////////////
;(function(){
	var boxWidth = 50;

	var geometry = new THREE.BoxGeometry(boxWidth, boxWidth, boxWidth);
	var material = new THREE.MeshBasicMaterial({
		map: new THREE.TextureLoader().load('images/box.png', function onLoad(texture){
			texture.wrapS = THREE.RepeatWrapping;
			texture.wrapT = THREE.RepeatWrapping;
			texture.repeat.set(boxWidth, boxWidth);
			// texture.anisotropy = renderer.getMaxAnisotropy()
		}),
		color: 0x01BE00,
		side: THREE.BackSide
	});
	var skybox = new THREE.Mesh(geometry, material);
	scene.add(skybox);

	var geometry = new THREE.PlaneGeometry(boxWidth, boxWidth);
	var material = new THREE.MeshBasicMaterial({
		map: new THREE.TextureLoader().load('images/box.png', function onLoad(texture){
			texture.wrapS = THREE.RepeatWrapping;
			texture.wrapT = THREE.RepeatWrapping;
			texture.repeat.set(boxWidth, boxWidth);
			
			texture.anisotropy = renderer.getMaxAnisotropy()
		}),
		color: 0x01BE00,
	});
	var ground = new THREE.Mesh(geometry, material);
	ground.position.y = -1
	ground.lookAt(scene.position)
	scene.add(ground);
	
	// debugger;
})()

//////////////////////////////////////////////////////////////////////////////
//              Handle reticles
//////////////////////////////////////////////////////////////////////////////

;(function(){

	var canvas = document.createElement( 'canvas' );
	canvas.width = 128;
	canvas.height = 128;
	var texture = new THREE.CanvasTexture( canvas );
	var context = canvas.getContext( '2d' );

	function updateDrawing(){
		// draw a circle
		context.save()
		context.clearRect(0,0, canvas.width, canvas.height)
		context.fillStyle	= "rgba(0,127,0,0.5)";
		context.beginPath();
		context.arc(canvas.width/2, canvas.height/2, canvas.width/2, 0, Math.PI*2, true); 
		context.closePath();
		context.fill();
		context.restore()

		// draw the player
		context.save()
		context.fillStyle	= "rgba(255,255,255,1.0)"			
		context.translate(canvas.width/2, canvas.height/2)
		context.fillRect(-5,-5, 5, 5)
		context.restore()

		// draw each enemy
		var mapRadius		= 10
		enemiesObject3D.forEach(function(enemyObject3D){
			var position	= enemyObject3D.position.clone()
			camera.updateMatrixWorld(true)
			camera.worldToLocal(position)
			var canvasX	= (-position.x / mapRadius) * (0.9*canvas.width/2)
			var canvasY	= (-position.z / mapRadius) * (0.9*canvas.height/2)
			
			context.save()
			context.fillStyle	= "rgba(127,127,127,1.0)"			
			context.translate(canvas.width/2, canvas.height/2)
			context.translate(-canvasX, -canvasY)
			context.fillRect(-5,-5, 5, 5)
			context.restore()
		})
		
		// update the texture
		texture.needsUpdate = true;
	}
	onRenderFcts.push(function(){
		updateDrawing()
	})

	// var textureLoader = new THREE.TextureLoader();
	// var texture = textureLoader.load( "images/sprite0.png" );
	var material = new THREE.SpriteMaterial( {
		map: texture, 
		color: 0xffffff, 
		// opacity: 0.2,
		depthTest: false
	} );
	var scoreObject3D = new THREE.Sprite( material )
	scoreObject3D.scale.multiplyScalar(0.5)
	scoreObject3D.position.x = -1
	scoreObject3D.position.z = -2
	scene.add(scoreObject3D)
// window.scoreObject3D = scoreObject3D

	// make the reticle in front of the camera
	onRenderFcts.push(function(){
		scoreObject3D.position.set(-1,0,-2)
		camera.updateMatrixWorld(true)
		camera.localToWorld(scoreObject3D.position)
	})
})()
//////////////////////////////////////////////////////////////////////////////
//              Handle reticles
//////////////////////////////////////////////////////////////////////////////

;(function(){

	var textureLoader = new THREE.TextureLoader();
	var map = textureLoader.load( "images/sprite0.png" );
	var material = new THREE.SpriteMaterial( {
		map: map, 
		color: 0xffffff, 
		opacity: 0.2,
		depthTest: false
	} );
	var reticle = new THREE.Sprite( material )
	reticle.scale.multiplyScalar(0.5)
	reticle.position.z = -2
	scene.add(reticle)

window.reticle = reticle
	
	// make the reticle in front of the camera
	onRenderFcts.push(function(){
		reticle.position.set(0,0,-2)
		camera.updateMatrixWorld(true)
		camera.localToWorld(reticle.position)
	})
	
	var hoverDuration = 1.0;
	var hoverStartedAt = null

	onRenderFcts.push(function(){
		var mouse = new THREE.Vector2(0,0)
		// find intersections
		var raycaster = new THREE.Raycaster();
		raycaster.setFromCamera( mouse, camera );
		var intersects = raycaster.intersectObjects( enemiesObject3D );
		var intersecting = intersects.length > 0 ? true : false
		var intersectingMesh = intersects.length > 0 ? intersects[0].object : null
		// console.log('intersecting', intersecting)
		
		
		// start hovering if needed
		if( intersecting === true ){
			if( hoverStartedAt === null ){
				hoverStartedAt = Date.now()/1000;
		// console.log('intersecting', intersects[0])
			}
		}

		// stop hovering if needed
		if( intersecting === false ){
		 	if( hoverStartedAt !== null ){
				hoverStartedAt = null
			}
		}

		if( hoverStartedAt !== null ){
			var hoverSince = Date.now()/1000 - hoverStartedAt;
			
			if( hoverSince >= hoverDuration ){
				hoverStartedAt = null
				// var mesh
				intersectingMesh.userData.setInitialPosition()
			}
		}
		
		
		if( hoverStartedAt !== null ){
			var hoverSince = Date.now()/1000 - hoverStartedAt;
			var angle = - hoverSince/hoverDuration * Math.PI * 2
			reticle.material.rotation = angle
			reticle.material.opacity = 0.6	
		}else{
			reticle.material.rotation = 0	
			reticle.material.opacity = 0.2	
		}
	})
})()

//////////////////////////////////////////////////////////////////////////////
//              Code Separator
//////////////////////////////////////////////////////////////////////////////

var enemiesObject3D = []

;(function(){
	var geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
	var material = new THREE.MeshNormalMaterial();
	var monster = new THREE.Mesh(geometry, material);
	
	for(var i = 0; i < 10; i++){
		;(function(){
			var velocity = new THREE.Vector3
			var speed = 0.05
			var direction = 0, distance = 1;


			var mesh = monster.clone()
			enemiesObject3D.push(mesh)
			scene.add(mesh)

			// add sound
			var sound = new THREE.PositionalAudio( listener );
			mesh.add( sound );

			
			new Promise(function(resolve){
				audioLoader.load( 'sounds/179142__jaraxe__zombie-yell2.wav', function( buffer ) {
					sound.setBuffer( buffer );
					sound.setLoop(true);
					sound.setVolume(0.2);
					sound.play()
					resolve()
				});				
				
				// var oscillator = listener.context.createOscillator();
				// oscillator.type = 'sawtooth';
				// oscillator.frequency.value = 144;
				// // oscillator.type = 'sine';
				// // oscillator.frequency.value = 2500;
				// oscillator.start(0);
				// sound.setNodeSource(oscillator);
				// sound.setVolume(0.05);
				// sound.setRolloffFactor(2)
				// sound.setRefDistance( 3 );
				// sound.panner.distanceModel = 'exponential'
				// sound.panner.panningModel = 'HRTF'
				// resolve()
			}).then(function(resolve){
				console.log('sound loaded')
			})
			
			// mesh.add(sound);


			mesh.userData.setInitialPosition = function(){
				if( sound.source.buffer ){
					sound.stop()
					sound.isPlaying = false
					sound.play()
				}

				direction = THREE.Math.randFloat(0, Math.PI*2)
				// direction = 3*Math.PI/2
				distance = 10
				distance = 8 + THREE.Math.randFloatSpread(4)
				mesh.position.x = distance * Math.cos(direction) 
				mesh.position.z = distance * Math.sin(direction)
				mesh.lookAt(scene.position)

				velocity.x = -speed * Math.cos(direction)
				velocity.z = -speed * Math.sin(direction)
			}

			var clock = new THREE.Clock
			mesh.userData.update = function(){
				var deltaAngle = clock.getDelta() * Math.PI
				mesh.rotateX( deltaAngle )

				mesh.position.add(velocity)
				
				if( mesh.position.length() < 1 ){
					mesh.userData.setInitialPosition()
				}
			}
						
			//////////////////////////////////////////////////////////////////////////////
			//		Code Separator
			//////////////////////////////////////////////////////////////////////////////

			onRenderFcts.push(function(){
				mesh.userData.update()
			})
			
			mesh.userData.setInitialPosition()
		})()		
	}

})()





</script>

</html>
